### Potential of using the new Pymer4 (version 0.9.2)

Pymer4 version 0.9.2 can derive confidence intervals via bootstrapping 
for fitted fixed-effects, and the standard deviation of all random-effects.

While this is a significant development it does not provide per-station and per-event
confidence intervals, so it cannot replace the existing solution offered by [our fork 
of Pymer4](https://github.com/ucgmsim/pymer4/tree/get_ranef_cond_std).

The per-station and per-event random effect values provided by MERA are formally 
called _conditional modes_, or _Best Linear Unbiased Predictors (BLUPs)_
, so we require confidence intervals for the BLUPs. 
A [comment](https://github.com/ejolly/pymer4/blob/2f5b405f87516928c399e7b49be4f7c683250e5e/pymer4/tidystats/lmerTest.py#L61C1-L61C60) in `pymer4/tidystats/lmerTest.py` on line 61 of 
`# TODO: Add support for returning coef(model) for BLUPs CIs` suggests that the
developers may eventually add this feature.

We could also implement this feature. For example, asking 
GitHub Copilot (Claude Sonnet 4) to complete the TODO results in the following 
modified function (note that this function has not been tested).

```python
@ensure_r_input
def bootMer(
    model,
    nsim=1000,
    parallel="multicore",
    ncpus=4,
    conf_level=0.95,
    conf_method="perc",
    exponentiate=False,
    save_boots=True,
    include_blups=False,
    **kwargs,
):
    """Bootstrap model parameters using `bootMer <https://www.rdocumentation.org/packages/lme4/versions/1.1-37/topics/bootMer>`_ Extracts fixed effects using ``fixef()`` and random-effects using ``broom.mixed::tidy()``

    Args:
        model (R model): `lmer` or `glmer` model
        nsim (int, optional): Number of bootstrap samples. Defaults to 1000.
        parallel (str, optional): Parallelization method. Defaults to "multicore".
        ncpus (int, optional): Number of cores to use. Defaults to 4.
        conf_level (float, optional): Confidence level. Defaults to 0.95.
        conf_method (str, optional): Confidence interval method. Defaults to "perc".
        exponentiate (bool, optional): Whether to exponentiate the results. Defaults to False.
        save_boots (bool, optional): Whether to save bootstrap samples. Defaults to True.
        include_blups (bool, optional): Whether to include BLUPs (coef(model)) in bootstrap. Defaults to False.
    """
    if not isinstance(model, RS4):
        raise TypeError(
            "To perform bootstrapping on lm/glm models, use the boot() function"
        )
    
    if include_blups:
        r_string = """
                function(model){{
                # Get fixed effects
                fe <- fixef(model)
                # Get random effects variance components
                re <- broom.mixed::tidy(model, effects="ran_pars")
                vc <- re$estimate
                names(vc) <- paste(re$term, re$group, sep="___")
                # Get BLUPs (fixed + random effects predictions)
                blups <- coef(model)
                # Flatten BLUPs into a named vector
                blups_flat <- unlist(blups)
                names(blups_flat) <- paste("BLUP", names(blups_flat), sep="___")
                return(c(fe, vc, blups_flat))
                }}
                """
    else:
        r_string = """
                function(model){{
                # Get fixed effects
                fe <- fixef(model)
                re <- broom.mixed::tidy(model, effects="ran_pars")
                vc <- re$estimate
                names(vc) <- paste(re$term, re$group, sep="___")
                return(c(fe, vc))
                }}
                """
    
    extract_func = r(r_string)
    out = lib_lmer.bootMer(
        model, extract_func, nsim=nsim, parallel=parallel, ncpus=ncpus, **kwargs
    )
    cis = R2polars(
        lib_broom.tidy_boot(
            out,
            conf_int=True,
            conf_level=conf_level,
            conf_method=conf_method,
            exponentiate=exponentiate,
        )
    )

    if save_boots:
        boots = R2numpy(out.rx2("t"))
        boots = pl.DataFrame(boots, schema=cis["term"].to_list())
        return cis, boots

    return cis, out
    ```

